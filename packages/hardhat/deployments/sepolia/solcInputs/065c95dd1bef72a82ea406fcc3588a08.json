{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/ScholarshipProgram.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\r\n\r\ncontract ScholarshipProgram is ReentrancyGuard, Pausable {\r\n    enum ProgramStatus {\r\n        Pending,\r\n        Active,\r\n        Expired,\r\n        Cancelled,\r\n        Completed\r\n    }\r\n    enum RequestStatus {\r\n        Pending,\r\n        Approved,\r\n        Rejected,\r\n        Expired,\r\n        Completed\r\n    }\r\n    enum Vote {\r\n        None,\r\n        Approve,\r\n        Reject\r\n    }\r\n\r\n    struct Request {\r\n        uint id;\r\n        string title;\r\n        string description;\r\n        uint value;\r\n        string[] mediaCIDs;\r\n        uint approvalCount;\r\n        uint rejectCount;\r\n        RequestStatus status;\r\n        uint createdAt;\r\n        uint votingDeadline;\r\n    }\r\n\r\n    struct Contribution {\r\n        address contributor;\r\n        uint contributedAmount;\r\n        uint timestamp;\r\n    }\r\n\r\n    string public title;\r\n    string public description;\r\n    string[] public mediaCIDs;\r\n    address public creator;\r\n    uint public goal;\r\n    ProgramStatus public status;\r\n    uint public createdAt;\r\n    uint public expiryDate;\r\n\r\n    uint public approversCount;\r\n    uint public nextRequestId;\r\n    uint public constant APPROVAL_THRESHOLD = 60;\r\n    uint public constant MIN_CONTRIBUTION_PERCENTAGE = 1;\r\n    uint public constant MAX_REQUEST_PERCENTAGE = 30;\r\n    uint public constant VOTING_PERIOD = 7 days;\r\n    uint public constant PROGRAM_DURATION = 90 days;\r\n\r\n    mapping(address => bool) public approvers;\r\n    mapping(uint => Request) public requestsMap;\r\n    mapping(uint => mapping(address => Vote)) public votesByRequest;\r\n    mapping(address => bool) public hasContributed;\r\n    mapping(address => uint) public totalContributions;\r\n\r\n    address[] public contributors;\r\n    Contribution[] public contributions;\r\n    uint[] public requestIds;\r\n\r\n    // modifiers\r\n    modifier onlyCreator() {\r\n        require(msg.sender == creator, \"Not the program creator\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyApprover() {\r\n        require(approvers[msg.sender], \"Not an approver\");\r\n        _;\r\n    }\r\n\r\n    modifier programActive() {\r\n        require(status == ProgramStatus.Active, \"Program not active\");\r\n        _;\r\n    }\r\n\r\n    modifier notExpired() {\r\n        require(block.timestamp < expiryDate, \"Program expired\");\r\n        _;\r\n    }\r\n\r\n    modifier hasBalance() {\r\n        require(address(this).balance > 0, \"No funds available\");\r\n        _;\r\n    }\r\n\r\n    modifier validRequest(uint _requestId) {\r\n        require(_requestId > 0 && _requestId <= nextRequestId, \"Invalid request ID\");\r\n        _;\r\n    }\r\n\r\n    // events\r\n    event ProgramCreated(address indexed creator, string title, uint goal, uint expiryDate);\r\n    event Contributed(address indexed contributor, uint amount, bool becameApprover);\r\n    event ProgramActivated(uint timestamp, uint totalFunds);\r\n    event ProgramCancelled(uint timestamp, uint refundedAmount);\r\n    event ProgramExpired(uint timestamp);\r\n    event ProgramCompleted(uint timestamp);\r\n\r\n    event RequestCreated(uint indexed requestId, string title, uint value, uint votingDeadline);\r\n    event VoteCast(uint indexed requestId, address indexed voter, bool approved);\r\n    event RequestApproved(uint indexed requestId, uint timestamp);\r\n    event RequestExpired(uint indexed requestId, uint timestamp);\r\n    event RequestRejected(uint indexed requestId, uint timestamp);\r\n    event RequestCompleted(uint indexed requestId, uint value, uint timestamp);\r\n\r\n    event FundsReleased(uint indexed requestId, address recipient, uint amount);\r\n    event RefundAvailable(address indexed programAddress);\r\n    event RefundProcessed(address indexed contributor, uint amount);\r\n    event MediaUploaded(uint indexed requestId, string[] mediaCIDs);\r\n\r\n    constructor(\r\n        string memory _title,\r\n        string memory _description,\r\n        uint _goal,\r\n        string[] memory _mediaCIDs,\r\n        address _creator\r\n    ) {\r\n        require(_goal > 0, \"Goal must be positive\");\r\n        require(bytes(_title).length > 0, \"Title required\");\r\n        require(_creator != address(0), \"Invalid creator address\");\r\n\r\n        title = _title;\r\n        description = _description;\r\n        goal = _goal;\r\n        mediaCIDs = _mediaCIDs;\r\n        creator = _creator;\r\n        status = ProgramStatus.Pending;\r\n        createdAt = block.timestamp;\r\n        expiryDate = block.timestamp + PROGRAM_DURATION;\r\n\r\n        emit ProgramCreated(_creator, _title, _goal, expiryDate);\r\n    }\r\n\r\n    // contribute function\r\n    function contribute() external payable nonReentrant notExpired whenNotPaused {\r\n        require(msg.value > 0, \"Contribution must be positive\");\r\n        require(status == ProgramStatus.Pending || status == ProgramStatus.Active, \"Invalid program status\");\r\n\r\n        bool becameApprover = false;\r\n        uint minContribution = (goal * MIN_CONTRIBUTION_PERCENTAGE) / 100;\r\n\r\n        totalContributions[msg.sender] += msg.value;\r\n\r\n        // add contribution\r\n        contributions.push(\r\n            Contribution({ contributor: msg.sender, contributedAmount: msg.value, timestamp: block.timestamp })\r\n        );\r\n\r\n        if (!hasContributed[msg.sender]) {\r\n            contributors.push(msg.sender);\r\n            hasContributed[msg.sender] = true;\r\n        }\r\n\r\n        if (totalContributions[msg.sender] >= minContribution && !approvers[msg.sender]) {\r\n            approvers[msg.sender] = true;\r\n            approversCount++;\r\n            becameApprover = true;\r\n        }\r\n\r\n        emit Contributed(msg.sender, msg.value, becameApprover);\r\n\r\n        // check if the program reach goal to be activated\r\n        if (address(this).balance >= goal && status == ProgramStatus.Pending) {\r\n            status = ProgramStatus.Active;\r\n            emit ProgramActivated(block.timestamp, address(this).balance);\r\n        }\r\n    }\r\n\r\n    // create spending request\r\n    function createRequest(\r\n        string memory _title,\r\n        string memory _description,\r\n        uint _value,\r\n        string[] memory _mediaCID\r\n    ) external onlyCreator programActive nonReentrant {\r\n        require(bytes(_title).length > 0, \"Title required\");\r\n        require(_value > 0, \"Value must be positive\");\r\n        require(_value <= (address(this).balance * MAX_REQUEST_PERCENTAGE) / 100, \"Exceeds maximum request amount\");\r\n\r\n        nextRequestId++;\r\n        Request storage newRequest = requestsMap[nextRequestId];\r\n\r\n        newRequest.id = nextRequestId;\r\n        newRequest.title = _title;\r\n        newRequest.description = _description;\r\n        newRequest.value = _value;\r\n        newRequest.mediaCIDs = _mediaCID;\r\n        newRequest.status = RequestStatus.Pending;\r\n        newRequest.createdAt = block.timestamp;\r\n        newRequest.votingDeadline = block.timestamp + VOTING_PERIOD;\r\n\r\n        requestIds.push(nextRequestId);\r\n\r\n        emit RequestCreated(nextRequestId, _title, _value, newRequest.votingDeadline);\r\n    }\r\n\r\n    // vote on request\r\n    function vote(uint _requestId, bool _approve) external validRequest(_requestId) onlyApprover nonReentrant  {\r\n        Request storage request = requestsMap[_requestId];\r\n\r\n        require(request.status == RequestStatus.Pending, \"Request not pending\");\r\n        require(!isRequestExpired(_requestId), \"Voting period ended\");\r\n        require(votesByRequest[_requestId][msg.sender] == Vote.None, \"Already voted\");\r\n\r\n        if (_approve) {\r\n            votesByRequest[_requestId][msg.sender] = Vote.Approve;\r\n            request.approvalCount++;\r\n        } else {\r\n            votesByRequest[_requestId][msg.sender] = Vote.Reject;\r\n            request.rejectCount++;\r\n        }\r\n\r\n        emit VoteCast(_requestId, msg.sender, _approve);\r\n\r\n        uint minApprovalsNeeded = (approversCount * APPROVAL_THRESHOLD + 99) / 100;\r\n        uint totalVotes = request.approvalCount + request.rejectCount;\r\n\r\n        bool shouldFinalize = false;\r\n\r\n        // enough approvals\r\n        if (request.approvalCount >= minApprovalsNeeded) {\r\n            shouldFinalize = true;\r\n        }\r\n        // rejection too much\r\n        else if (request.rejectCount > approversCount - minApprovalsNeeded) {\r\n            shouldFinalize = true;\r\n        }\r\n        // all voted\r\n        else if (totalVotes >= approversCount) {\r\n            shouldFinalize = true;\r\n        }\r\n        // deadline\r\n        else if (block.timestamp >= request.votingDeadline) {\r\n            shouldFinalize = true;\r\n        }\r\n\r\n        if (shouldFinalize) {\r\n            _checkVotingThreshold(_requestId);\r\n        }\r\n    }\r\n\r\n    // update the request status by checking if it passed the threshold\r\n    function _checkVotingThreshold(uint _requestId) internal {\r\n        Request storage request = requestsMap[_requestId];\r\n\r\n        if (approversCount == 0) return;\r\n\r\n        uint totalVotes = request.approvalCount + request.rejectCount;\r\n\r\n        uint approvalRate = (request.approvalCount * 100) / totalVotes;\r\n\r\n        if (approvalRate >= APPROVAL_THRESHOLD) {\r\n            request.status = RequestStatus.Approved;\r\n            emit RequestApproved(_requestId, block.timestamp);\r\n        } else {\r\n            request.status = RequestStatus.Rejected;\r\n            emit RequestRejected(_requestId, block.timestamp);\r\n        }\r\n    }\r\n\r\n    // finalize approved request\r\n    function finalizeRequest(uint _requestId) external onlyCreator programActive nonReentrant validRequest(_requestId) {\r\n        Request storage request = requestsMap[_requestId];\r\n\r\n        require(request.status == RequestStatus.Approved, \"Request not approved\");\r\n        require(address(this).balance >= request.value, \"Insufficient funds\");\r\n\r\n        // transfer the fund\r\n        (bool success, ) = payable(creator).call{ value: request.value }(\"\");\r\n        require(success, \"Transfer failed\");\r\n\r\n        request.status = RequestStatus.Completed;\r\n\r\n        emit FundsReleased(_requestId, creator, request.value);\r\n        emit RequestCompleted(_requestId, request.value, block.timestamp);\r\n\r\n        // check and update if the balance is 0 which means the program is completed\r\n        if (address(this).balance == 0) {\r\n            status = ProgramStatus.Completed;\r\n            emit ProgramCompleted(block.timestamp);\r\n        }\r\n    }\r\n\r\n    // upload media\r\n    function uploadMedia(uint _requestId, string[] memory _mediaCIDs) external onlyCreator validRequest(_requestId) {\r\n        Request storage request = requestsMap[_requestId];\r\n\r\n        for (uint i=0; i < _mediaCIDs.length; i++) {\r\n            request.mediaCIDs.push(_mediaCIDs[i]);\r\n        }\r\n        emit MediaUploaded(_requestId, _mediaCIDs);\r\n    }\r\n\r\n    // cancel program\r\n    function cancelProgram() external onlyCreator nonReentrant {\r\n        require(status == ProgramStatus.Pending || status == ProgramStatus.Active, \"Cannot cancel program\");\r\n\r\n        uint refundAmount = address(this).balance;\r\n        _processRefunds();\r\n\r\n        status = ProgramStatus.Cancelled;\r\n        emit ProgramCancelled(block.timestamp, refundAmount);\r\n    }\r\n\r\n    function _processRefunds() internal {\r\n        emit RefundAvailable(address(this));\r\n    }\r\n\r\n    function withdrawRefund() external nonReentrant {\r\n        require(status == ProgramStatus.Cancelled || status == ProgramStatus.Expired, \"Refunds not available\");\r\n\r\n        uint amount = totalContributions[msg.sender];\r\n        require(amount > 0, \"No refund available\");\r\n\r\n        totalContributions[msg.sender] = 0;\r\n\r\n        (bool success, ) = payable(msg.sender).call{ value: amount }(\"\");\r\n        require(success, \"Refund transfer failed\");\r\n\r\n        emit RefundProcessed(msg.sender, amount);\r\n    }\r\n\r\n    // check and update program n requests expiry status\r\n    function updateStatus() external {\r\n        uint currentTime = block.timestamp;\r\n\r\n        if (currentTime >= expiryDate && status == ProgramStatus.Pending) {\r\n            _processRefunds();\r\n            status = ProgramStatus.Expired;\r\n            emit ProgramExpired(currentTime);\r\n        }\r\n\r\n        for (uint i = 0; i < requestIds.length; i++) {\r\n            uint requestId = requestIds[i];\r\n            isRequestExpired(requestId);\r\n        }\r\n    }\r\n\r\n    // check n update request expiry\r\n    function isRequestExpired(uint _requestId) public validRequest(_requestId) returns (bool) {\r\n        Request storage request = requestsMap[_requestId];\r\n        uint currentTime = block.timestamp;\r\n\r\n        if (request.status == RequestStatus.Pending && request.votingDeadline >= currentTime) {\r\n            return false;\r\n        }\r\n\r\n        request.status = RequestStatus.Expired;\r\n        emit RequestExpired(_requestId, currentTime);\r\n        return true;\r\n    }\r\n\r\n    // emergency functions\r\n    function pause() external onlyCreator {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external onlyCreator {\r\n        _unpause();\r\n    }\r\n\r\n    // getters\r\n    function getRequest(uint _requestId) external view validRequest(_requestId) returns (Request memory) {\r\n        Request storage request = requestsMap[_requestId];\r\n        return\r\n            Request({\r\n                id: request.id,\r\n                title: request.title,\r\n                description: request.description,\r\n                value: request.value,\r\n                mediaCIDs: request.mediaCIDs,\r\n                approvalCount: request.approvalCount,\r\n                rejectCount: request.rejectCount,\r\n                status: request.status,\r\n                createdAt: request.createdAt,\r\n                votingDeadline: request.votingDeadline\r\n            });\r\n    }\r\n\r\n    function getAllRequests() external view returns (Request[] memory) {\r\n        Request[] memory allRequests = new Request[](requestIds.length);\r\n\r\n        for (uint i = 0; i < requestIds.length; i++) {\r\n            Request storage request = requestsMap[requestIds[i]];\r\n            allRequests[i] = Request({\r\n                id: request.id,\r\n                title: request.title,\r\n                description: request.description,\r\n                value: request.value,\r\n                mediaCIDs: request.mediaCIDs,\r\n                approvalCount: request.approvalCount,\r\n                rejectCount: request.rejectCount,\r\n                status: request.status,\r\n                createdAt: request.createdAt,\r\n                votingDeadline: request.votingDeadline\r\n            });\r\n        }\r\n\r\n        return allRequests;\r\n    }\r\n\r\n    function getContributions() external view returns (Contribution[] memory) {\r\n        return contributions;\r\n    }\r\n\r\n    function getContributors() public view returns (address[] memory) {\r\n        return contributors;\r\n    }\r\n\r\n    function getVote(uint _requestId, address _voter) external view validRequest(_requestId) returns (Vote) {\r\n        return votesByRequest[_requestId][_voter];\r\n    }\r\n\r\n    function getProgramInfo()\r\n        external\r\n        view\r\n        returns (\r\n            string memory _title,\r\n            string memory _description,\r\n            string[] memory _mediaCIDs,\r\n            address _creator,\r\n            uint _goal,\r\n            uint _balance,\r\n            ProgramStatus _status,\r\n            uint _approversCount,\r\n            uint _createdAt,\r\n            uint _expiryDate\r\n        )\r\n    {\r\n        return (\r\n            title,\r\n            description,\r\n            mediaCIDs,\r\n            creator,\r\n            goal,\r\n            address(this).balance,\r\n            status,\r\n            approversCount,\r\n            createdAt,\r\n            expiryDate\r\n        );\r\n    }\r\n\r\n    function isApprover(address _address) external view returns (bool) {\r\n        return approvers[_address];\r\n    }\r\n\r\n    // receive function\r\n    receive() external payable {\r\n        revert(\"Use contribute() function\");\r\n    }\r\n\r\n    fallback() external payable {\r\n        revert(\"Function not found\");\r\n    }\r\n}\r\n"
    },
    "contracts/ScholarshipProgramFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT \r\npragma solidity ^0.8.30;\r\nimport \"./ScholarshipProgram.sol\";\r\n\r\ncontract ScholarshipProgramFactory {\r\n    address[] public deployedPrograms;\r\n    mapping(address => address[]) public creatorPrograms;\r\n    \r\n    event ProgramCreated(\r\n        address indexed programAddress,\r\n        address indexed creator,\r\n        string title,\r\n        string description,\r\n        string[] mediaCIDs,\r\n        uint goal,\r\n        uint timestamp\r\n    );\r\n\r\n    function createProgram(\r\n        string memory _title,\r\n        string memory _description,\r\n        uint _goal,\r\n        string[] memory _mediaCIDs\r\n    ) external returns (address) {\r\n        require(_goal > 0, \"Goal must be positive\");\r\n        require(bytes(_title).length > 0, \"Title required\");\r\n\r\n        ScholarshipProgram newProgram = new ScholarshipProgram(\r\n            _title,\r\n            _description,\r\n            _goal,\r\n            _mediaCIDs,\r\n            msg.sender\r\n        );\r\n\r\n        address programAddress = address(newProgram);\r\n        deployedPrograms.push(programAddress);\r\n        creatorPrograms[msg.sender].push(programAddress);\r\n\r\n        emit ProgramCreated(\r\n            programAddress,\r\n            msg.sender,\r\n            _title,\r\n            _description,\r\n            _mediaCIDs,\r\n            _goal,\r\n            block.timestamp\r\n        );\r\n\r\n        return programAddress;\r\n    }\r\n\r\n    function getDeployedPrograms() external view returns (address[] memory) {\r\n        return deployedPrograms;\r\n    }\r\n\r\n    function getCreatorPrograms(address _creator) external view returns (address[] memory) {\r\n        return creatorPrograms[_creator];\r\n    }\r\n\r\n    function getProgramCount() external view returns (uint) {\r\n        return deployedPrograms.length;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}